# 2022.11.21 update security 개발일지 

1. HTML의 form 방식으로 로그인 인증을 진행하는 로그인 인증방식을 폼 로그인 인증이라고 부른다.
2. build gradle에 의존라이브러리 implementation 'org.springframework.boot:spring-boot-starter-security'을 추가하였음 => Spring Security가 내부적으로 제공해주는 디폴트 로그인 페이지로 접근 가능
   1. user, 제공해주는 비밀번호를 입력하면 접속 가능하다. 
   => 하지만 매번 임시 패스워드를 제공받아 접속 할 수 없다는 한계가 있다. 
   => Spring Security Configuration(=구성)을 통해 해결가능하다.
   
   2. 따라서 SecurityConfiguration을 생성하여 설정을 진행하였다.
   => @Configuration (애너테이션)만 추가해주면 된다.
   
   3. UserDetailsManager 인터페이스를 통해 UserDetails를 관리하며 유저의 핵심정보를 포함한다.
   => 이러한 정보는 메모리 상에서 관리하그 있으므로 InMemoryUserDetailsManager 구현체를 사용한다. 
   따라서, 해당 Bean이 가지고 있는 사용자의 인증 정보가 클라이언트의 요청으로 넘어올 경우 정상적인 인증 프로세스를 수행한다. 
   
   #Deprecated 상태
   일반적으로  API가 향후 버전에서는 더 이상 사용되지 않고 제거될 수 있다라는 의미이지만
    withDefaultPasswordEncoder() 메서드의 Deprecated는 Production 환경에서 인증을 위한 사용자 정보를 고정해서 사용하지 말라는 경고의 의미이다.

   4. SecurityFilterChain메서드를 정의해여 HTTP 보안 설정을 구성
   => HttpSecurity는 HTTP 요청에 대한 보안 설정을 구성하기 위한 핵심 클래스가 된다.
   
   Role 분리를 통해 ADIN 권한과 USER 권한의 접근 사이트 구성
3. build gradle에 의존라이브러리 implementation 'org.thymeleaf.extras:thymeleaf-extras-springsecurity5'

4. InMemory User, Adim을 사용하는 이유
=> 데이터베이스 연동 없이 변동사항을 확인하기 위해
=>  회원 가입 폼에서 전달 받은 패스워드는 InMemory User로 등록하기 전에 암호화 되어야 한다.
=> PasswordEncoder의 디폴트 암호화 알고리즘은 bcrypt이다.

5. JavaConfiguration 구성
=>  MemberService 인터페이스의 구현 클래스인 InMemoryMemberService를 Spring Bean으로 등록
=> 데이터베이스 연동 없이 메모리에 Spring Security의 User를 등록해야 하므로 UserDetailsManager 객체가 필요
=> 패스워드를 암호화 한 후에 등록해야 하므로 Spring Security에서 제공하는 PasswordEncoder 객체가 필요
=> 따라서 이 두 객체를 InMemoryMemberService 객체 생성 시, DI 해준다.

6. InMemoryMemberService 구현
=> JavaConfiguration을 이용해 Bean을 등록 / implements MemberService를 지정

=> UserDetailsManager와 PasswordEncoder를 DI
   UserDetailsManager는 Spring Security의 User를 관리하는 관리자 역할을 한다.
   PasswordEncoder 는 Spring Security User를 등록할 때 패스워드를 암호화 해주는 클래스이다.

=> User의 권한(Authority)을 지정
   createAuthorities(Member.MemberRole.ROLE_USER.name());를 이용해 User의 권한 목록을 List<GrantedAuthority>로 생성
Role 베이스 형태의 권한을 지정할 때 ‘Roll_’ + 권한명 형태로 지정해 주어야 한다.

=> asswordEncoder 를 이용해 등록할 User의 패스워드를 암호화

=> Spring Security User로 등록하기 위해 UserDetails 를 생성

=> UserDetailsManager의 createUser() 메서드를 이용해서 User를 등록

7. H2 콘솔 사용을 위한 SecurityConfiguration 설정
=> frameOptions()는 HTML 태그 중에서 <frame>이나 <iframe>, <object> 태그에서 페이지를 렌더링 할지의 여부를 결정하는 기능을 한다. 
   디폴트 값은 DENY이다. 
=> .frameOptions().sameOrigin()을 호출하면 동일 출처로부터 들어오는 request만 페이지 렌더링을 허용

8. DB 사용을 위한 JavaConfiguration 설정
=> DBMemberService는 내부에서 데이터를 데이터베이스에 저장하고, 패스워드를 암호화 해야 하므로 (1-1)과 같이 MemberRepository와 PasswordEncoder 객체를 DI

9. DBMemberService 구현
=> 생성자를 통해 MemberRepository와 PasswordEncoder Bean 객체를 DI
=> PasswordEncoder를 이용해 패스워드를 암호화
=> 암호화 된 패스워드를 password 필드에 다시 할당

10. 데이터베이스에서 조회한 인증 정보를 기반으로 인증을 처리하는 Custom UserDetailsService인 HelloUserDetailsService 클래스 작성
=> UserDetailsService 인터페이스를 구현
=> User를 조회하고, 조회한 User의 권한(Role) 정보를 생성하기 위해 MemberRepository와 HelloAuthorityUtils 클래스를 DI
=> loadUserByUsername(String username)이라는 추상 메서드를 구현
=> HelloAuthorityUtils 를 이용해 데이터베이스에서 조회한 회원의 이메일 정보를 이용해 Role 기반의 권한 정보(GrantedAuthority) 컬렉션을 생성
=> User 클래스의 객체를 리턴하면 Spring Security가 이 정보를 이용해 인증 절차를 수행

11. Role 기반의 User 권한을 생성하기 위해 사용한 HelloAuthorityUtils 코드
=> AuthorityUtils 클래스를 이용해서 관리자용 권한 목록을 List<GrantedAuthority> 객체로 미리 생성
=> AuthorityUtils 클래스를 이용해서 일반 사용 권한 목록을 List<GrantedAuthority> 객체로 미리 생성
=> 파라미터로 전달 받은 이메일 주소가 application.yml 파일에서 가져온 관리자용 이메일 주소와 동일하다면 관리자용 권한인 List<GrantedAuthority> ADMIN_ROLES를 리턴

12. HelloUserDetailsService 리팩토링
=> User의 권한 정보를 생성하는 과정을 캡슐화
=> HelloUserDetails 클래스는 Member 엔티티 클래스를 상속하고 있기 때문에 HelloUserDetails를 리턴 받아 사용하는 측에서는 두 개 클래스의 객체를 모두 다 손쉽게 캐스팅해서 사용 가능하다는 장점이 있다.

13. User의 권한 정보 테이블 생성
=> @ElementCollection 애너테이션을 추가하면 User 권한 정보와 관련된 별도의 엔티티 클래스를 생성하지 않아도 간단하게 매핑 처리가 된다.