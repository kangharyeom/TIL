# JWT (JSON Web Token)이란 무엇인가?
CSR기반 자격 증명 방식이다.
즉, JSON으로 작성된 웹토큰이다.
JSON 포맷의 토큰 정보를 인코딩 후, 
인코딩 된 토큰 정보를 Secret Key로 서명(Sign)한 메시지를 Web Token으로써 인증 과정에 사용한다.
Header, payload, signature로 구성되어있다.

Header
Header는 이것이 어떤 종류의 토큰인지(지금의 경우엔 JWT), 어떤 알고리즘으로 Sign할지 정의한다.
- 어떤 종류의 토큰인가?
- 어떤 알고리즘으로 암호화 했는가?

Payload
Payload에는 서버에서 활용할 수 있는 사용자의 정보가 담겨 있다.
어떤 정보에 접근 가능한지에 대한 권한을 담을 수도 있고, 사용자의 이름 등 필요한 데이터를 담을 수 있다.
Payload는 다음으로 설명할 Signature를 통해 유효성이 검증될 정보이긴 하지만, 민감한 정보는 담지 않는 것이 좋다.
- 유저의 정보
- 권한을 부여받았는가
- 기타 필요한 정보

Signature
base64로 인코딩된 첫 번째, 그리고 두 번째 부분이 완성되었다면, 
Signature에서는 원하는 비밀 키(Secret Key)와 Header에서 지정한 알고리즘을 사용하여 Header와 Payload에 대해서 단방향 암호화를 수행한다.
암호화 된 메시지는 토큰의 위변조 유무를 검증하는데 사용된다.
- Header, Payload를 base64인코딩한 값과 salt값의 조합으로 암호화된 값 

# JWT의 종류
1. 액세스 토큰(Access Token)
Access Token은 보호된 정보들(사용자의 이메일, 연락처, 사진 등)에 접근할 수 있는 권한부여에 사용한다
클라이언트가 처음 인증을 받게 될 때(로그인 시), Access Token과 Refresh Token 두 가지를 다 받지만, 실제로 권한을 얻는 데 사용하는 토큰은 Access Token이다.
따라서 권한을 부여받는 것에는  Access Token만 가지고 있으면 된다.
하지만 Access Token을 탈취하는 경우 악의적인 요청을 보낼 수 있다.
따라서, 비교적 짧은 유효 기간을 두어 탈취되더라도 오랫동안 사용할 수 없도록 한다.
유효기간이 만료되면 Refresh Token으로 Access Token을 다시 부여받는다.

2. 리프레시 토큰(Refresh Token)
Access Token을 부여받기 위한 토큰이다.
정보를 지키는 것이 더 중요한 웹 애플리케이션은 Refresh Token을 사용하지 않는 곳이 많다.

# JWT 사용 예시
JWT는 권한 부여에 매우 유용하다.
새로 다운받은 A라는 앱이 Gmail과 연동되어 이메일을 읽어와야 한다고 가정하자.

이 경우, 사용자는
Gmail 인증서버에 로그인 정보(아이디, 비밀번호)를 제공하며, 인증에 성공할 경우, JWT를 발급받는다.
A 앱은 JWT를 사용해 해당 사용자의 이메일을 읽거나 사용할 수 있다.


# 토큰 기반 인증 절차

1. 클라이언트 => 서버 // id,password를 입력하여 login 요청
2. 서버 => 클라이언트 // 데이터베이스에서 해당 정보를 확인하고 JWT토큰 부여
3. http header에 토큰을 담아서 서버에 Get요청을 함
4. 서버는 토큰을 해독하고 응답을 보냄

# 토큰 기반 인증의 장점은?

1. 무상태성 & 확장성
- 서버는 클라이언트에 대한 정보를 저장할 필요X
- 토큰을 헤더에 추가함으로 인증절차 완료

2. 안정성
- 암호화한 토큰을 사용
- 암호화 키를 노출할 필요X

3. 어디서나 생성 가능
- 토큰을 생성하는 서버가 꼭 토큰을 만들지 않아도 됨

4. 권한 부여에 용이
- 토큰의 payload(내용물) 안에 어떤 정보에 접근 가능한지 정의
- Ex) 사진과 연락처 사용권한 부여 / 사진 권한만 부여 / 연락처 권한만 부여


# 세션 기반 자격 인증 방식
서버 측에 인증된 사용자의 정보를 세션 형태로 세션 저장소에 저장하는 방식
즉, 클라이언트 측에서 서버 측의 리소스를 요청하면 서버 측에서는 "서버측 리소스를 요청하는 클라이언트에게 우리가 정보를 줘도 괜찮은가?"를 
확인하기 위해 서버측 세션 저장소에 저장된 세션 정보와 사용자가 제공하는 정보가 일치한지 확인하는 방식 

# 세션 기반 자격 증명의 특징
1. 세션은 인증된 사용자 정보를 서버 측 세션 저장소에서 관리한다.
2. 생성된 사용자 세션의 고유 ID인 세션 ID는 클라이언트의 쿠키에 저장되어 request 전송 시, 인증된 사용자인지를 증명하는 수단으로 사용된다.
3. 세션 ID만 클라이언트 쪽에서 사용하므로 상대적으로 적은 네트워크 트래픽을 사용한다.
4. 서버 측에서 세션 정보를 관리하므로 보안성 측면에서 조금 더 유리하다.
5. 서버의 확장성 면에서는 세션 불일치 문제가 발생할 가능성이 높다.
6. 세션 데이터가 많아질수록 서버의 부담이 가중될 수 있다.
7. SSR(Server Side Rendering) 방식의 애플리케이션에 적합한 방식이다.

세션 기반의 자격 증명 방식은 인증된 사용자의 상태를 유지하기 위한 전통적인 방식이다.
따라서 이를 개선할 방법으로 사용되는 것이 토큰 기반 자격 증명 방식이다.

# 토큰 기반 자격 증명의 특징

1. 토큰에 포함된 인증된 사용자 정보는 서버 측에서 별도의 관리를 하지 않는다.
2. 생성된 토큰을 헤더에 포함시켜 request 전송 시, 인증된 사용자인지를 증명하는 수단으로 사용한다.
3. 토큰내에 인증된 사용자 정보 등을 포함하고 있으므로 세션에 비해 상대적으로 많은 네트워크 트래픽을 사용한다.
4. 기본적으로 서버 측에서 토큰을 관리하지 않으므로 보안성 측면에서 조금 더 불리하다.
5. 인증된 사용자 request의 상태를 유지할 필요가 없기 때문에 서버의 확장성 면에서 유리하고, 세션 불일치 같은 문제가 발생하지 않는다.
6. 토큰에 포함되는 사용자 정보는 토큰의 특성상 암호화가 되지 않기때문에 공격자에게 토큰이 탈취될 경우, 사용자 정보를 그대로 제공하게 된다. 따라서 민감한 정보는 토큰에 포함시키지 말아야 한다.
7. 기본적으로 토큰이 만료되기 전까지는 토큰을 무효화 시킬 수 없다.
8. CSR(Client Side Rendering) 방식의 애플리케이션에 적합한 방식이다.

# 각각의 방식의 개선 방향

1. 세션의 경우 서버 확장 시, 세션 불일치 문제가 발생할 수 있지만 Sticky Session, Session Clustering, Session 저장소의 외부 분리 등의 작업을 통해 보완을 하고 있다.
2. 토큰의 경우, 기본적으로 토큰 무효화를 할 수 없지만 key/value 쌍의 형태로 저장되는 Redis 같은 인메모리 DB에 무효화 시키고자 하는 토큰의 만료 시간을 짧게 주어 해당 토큰을 사용하지 못하게 하는 등의 방법을 사용해 토큰 무효화 문제를 보완하고 있다.


